import os
import sys
import parmed as pmd
import numpy as np
import argparse

babel = '/u/fd/ball4935/.linuxbrew/bin/babel'
antechamber = '/u/fd/ball4935/opt/amber18/bin/antechamber'
parmchk = '/u/fd/ball4935/opt/amber18/bin/parmchk2'
leaprc_forcefield_file = '/u/fd/ball4935/opt/amber18/dat/leap/cmd/leaprc.gaff2'
tleap = '/u/fd/ball4935/opt/amber18/bin/tleap'
orca = '/usr/local/orca_4_0_1_2_linux_x86-64/orca'
orca_2mkl = '/usr/local/orca_4_0_1_2_linux_x86-64/orca_2mkl'
bash = '/bin/bash'
python = '/u/fd/ball4935/opt/anaconda3/bin/python3'
gromacs = '/u/fd/ball4935/opt/gromacs-2018.3/bin/gmx_mpi'
mpirun = '/opt/openmpi2/bin/mpirun'
multiwfn = '/u/fd/ball4935/opt/Multiwfn_3.6_dev_bin_Linux/Multiwfn'


def get_args():
    """
    Get arguments to the tool with argparse
    :return: The arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("filename", action='store',
                        help='.xyz file(s) with optimised geometries from which to make .top and .gro files', nargs="+")
    parser.add_argument('-id', type=str, default='AAA',
                        help="Three letter name of the residue/molecule e.g LYS")

    parser.add_argument('-c', type=int, default=0,
                        help="Charge of the molecule Default: %(default)s")
    parser.add_argument('-m', type=int, default=1,
                        help="Multiplicity of the molecule. Default: %(default)s")
    parser.add_argument('-notrash', action='store_true', default=False,
                        help="Don't trash all the output files. Only .gro and .top will be left by default")

    return parser.parse_args()


def generate_pdb_file(filename):
    """
    From a .xyz file generate a .pdb using OpenBabel.
    :param filename: name of the xyz file e.g. test.xyz
    :return pdb_filename: name of the .pdb file generated by OpenBabel
    """
    pdb = filename.replace('.xyz', '.pdb')
    os.system(babel + ' -ixyz ' + filename + ' -opdb ' + pdb)
    return pdb


def run_antechamber(filename, chg=0, mult=1):
    """
    From a .pdb file run antechamber to get a .mol2 file with the appropriate parameters in.
    The -c bcc option tells antechamber to use the AM1-BCC charge model (RESP charges will generated later)
    in order to calculate the atomic point charges while the -s 2 option defines the verbosity of the status
    information provided by antechamber. In this case we have selected verbose output (2).
    :param filename: name of the pdb file
    :param chg: charge of the molecule
    :param mult: multiplicity of the molecule
    :return: the mol2 filename
    """

    mol2 = filename.replace('.pdb', '.mol2')
    os.system(antechamber + ' -i ' + filename + ' -fi pdb -o ' + mol2
              + ' -fo mol2 -c bcc -s 2 -nc ' + str(chg) + ' -m ' + str(mult))
    return mol2


def run_paramcheck(filename):
    """
    From a .mol2 file generated in antechamber run parmchk
    :param filename: name of the mol2 file
    :return: the frcmod filename
    """

    frcmod = filename.replace('.mol2', '.frcmod')
    os.system(parmchk + ' -i ' + filename + ' -f mol2 -o ' + frcmod)
    return frcmod


def generate_tleap_in(base_filename, residue_label):
    """
    From all files generated using antechamber and paramcheck now generate a tleap.in file
    :param base_filename: filename with no extension
    :param residue_label: name of the residue to use e.g LYS
    :return:
    """

    tleap_in_file = open('tleap.in', 'w')

    print('source ' + leaprc_forcefield_file, '\n',
          residue_label + ' = loadmol2 ' + base_filename + '.mol2', '\n',
          'check ' + residue_label, '\n',
          'loadamberparams ' + base_filename + '.frcmod', '\n',
          'saveoff ' + residue_label + ' ' + base_filename + '.lib ', '\n',
          'saveamberparm ' + residue_label + ' ' + base_filename + '.prmtop ' + base_filename + '.inpcrd', '\n',
          'quit',
          sep='',
          file=tleap_in_file)

    return 'tleap.in'


def run_tleap(filename):
    """
    Run the tleap command from amber. This will generate amber topology files
    :param filename: name of the .in file to execute with tleap
    """
    os.system(tleap + ' -f ' + filename)


def convert_amber2gromacs(base_filename):
    amber = pmd.load_file(base_filename + '.prmtop', base_filename + '.inpcrd')
    amber.save(base_filename + '.top', overwrite=True, format="gromacs")
    amber.save(base_filename + '.gro', overwrite=True, format="gro")


def get_residue_label(filename):
    """
    From an argument and filename (with no extension) generate a residue label e.g. LYS
    :param filename: name of the file to use for the default residue identifier
    :return: the residue label
    """

    try:
        if len(sys.argv[2]) == 3:
            return sys.argv[2].upper()

    except IndexError:
        return filename[:3].upper()


def modify_pdb(filename, residue_label):
    """
    Modify an input pdb file so that the atom labels are numbered e.g. C1, C2... and that the new residue label is
    added
    :param filename: name of the pdb file
    :param residue_label:
    :return: name of the modified pdb file
    """

    # TODO fix this function so it is less temperamental

    try:
        pdb_file = open(filename, 'r')

    except IOError as err:
        exit("I/O error({0}): {1}".format(err.errno, err.strerror))

    pdb_file_lines = [line for line in pdb_file]

    modfied_pdb_file = open(filename, 'w')

    n_elements_dict = {}

    for line in pdb_file_lines:
        if len(line.split()) == 11 or len(line.split()) == 12 and 'AUTHOR' not in line and 'COMPND' not in line:
            # If we are in the body of the pdb file (with the xyzs and labels etc.

            if 'ATOM' not in line:
                # If the pdb has recognised all the atoms, do not do anything

                atom_label = line.split()[2][0]
                if atom_label not in n_elements_dict.keys():
                    n_elements_dict[atom_label] = 1
                else:
                    n_elements_dict[atom_label] += 1

                line = (line.split()[:2] +
                        [str(atom_label) + str(n_elements_dict[atom_label])] +
                        [residue_label] +
                        line.split()[4:])

                try:
                    print("{:6s}{:5d} {:^5s} {:3s} {:4s}  {:8.3f}{:8.3f}{:8.3f}   {:6.2f}{:6.2f}  {:>2s}{:2s}".format(
                            line[0], int(line[1]), line[2], line[3], line[4],
                            float(line[5]), float(line[6]), float(line[7]),
                            float(line[8]), float(line[9]),
                            line[10], line[11]),
                          file=modfied_pdb_file)
                except IndexError:
                    print("{:6s}{:5d} {:^5s} {:3s} {:4s}  {:8.3f}{:8.3f}{:8.3f}   {:6.2f}{:6.2f}  {:>2s}".format(
                        line[0], int(line[1]), line[2], line[3], line[4],
                        float(line[5]), float(line[6]), float(line[7]),
                        float(line[8]), float(line[9]),
                        line[10]),
                        file=modfied_pdb_file)

        elif 'CONECT' not in line:
            print(line, end='', file=modfied_pdb_file)


def generate_orca_input(filename, chg, mult):
    """
    From a xyz file generate an ORCA input suitable for calculating RESP charges
    :param filename: name of the xyz file
    :param chg: charge of the molecule
    :param mult: mu,ltiplicity of the molecule
    :return: the name of the .inp file to execute with ORCA
    """

    def get_xyz_list():
        xyz_file = open(filename, 'r')
        n_atoms = int(xyz_file.readline())
        xyz_file.readline()  # Read the title line
        list_atomxyz = []

        for i in range(n_atoms):
            line = xyz_file.readline().split()

            try:
                atom, x, y, z = line
                list_atomxyz.append([atom, x, y, z])
            except ValueError:
                print('It looks like there is an error in the .xyz file')
                return []

        return list_atomxyz

    xyz_list = get_xyz_list()

    def generate_inp():

        keyword_line = '! RHF 6-31G(d) RIJCOSX def2/J PAL2'

        with open(inp_filename, 'w') as inp_file:
            print(keyword_line, file=inp_file)
            print('*xyz', chg, mult, file=inp_file)

            for xyz_line in xyz_list:
                atom, x, y, z = xyz_line
                print("{:<5s}{:10.5f}{:10.5f}{:10.5f}".format(atom, float(x), float(y), float(z)), file=inp_file)

            print('*', file=inp_file)

    inp_filename = filename.replace('.xyz', '.inp')
    generate_inp()

    return inp_filename


def check_frcmod_file(base_filename):
    """
    Check a frcmod file to make sure reasonable parameters exist
    :param base_filename: name of the file without the extension
    """

    filename = base_filename + '.frcmod'
    frcmod_file = open(filename, 'r')

    for line in frcmod_file:
        if 'ATTN' in line:
            print('A paramter was not avalible and is set to zero! The script '
                  'will now exit without running tleap or ParmEd')
            exit()


def run_orca(filename):
    """
    Run ORCA and generate an output (.out) file. Will check to see if the calculation has already been done
    and skip it if it has.
    :param filename: Name of the .inp file
    """

    out = filename.replace('.inp', '.out')
    orca_calc_done = False

    if os.path.exists(out):
        orca_out_file = open(out, 'r')
        for line in orca_out_file:
            if '****ORCA TERMINATED NORMALLY****' in line:
                orca_calc_done = True

    if orca_calc_done:
        print('Found ORCA run already complete')
    else:
        os.system(orca + ' ' + filename + ' > ' + out)


def generate_molden_file(base_filename):
    """
    Use the inbuilt ORCA utility to convert a .gbw to a .molden, for use with Multiwfn
    :param base_filename: filename with no extension
    """

    molden = base_filename + '.molden'

    os.system(orca_2mkl + ' ' + base_filename + ' -molden')
    os.system('mv ' + base_filename + '.molden.input ' + molden)

    return molden


def generate_multiwfn_script(base_filename):
    """
    Generate a .sh file suitable for running Multiwfn
    :param base_filename: name of the file without the extension
    :return: name of the .sh file
    """

    bash_script_filename = base_filename + '.sh'
    bash_script = open(bash_script_filename, 'w')

    print(multiwfn + ' ' + base_filename + '.molden > multiwfn_out.txt << EOF \n',
          '7 \n',
          '18 \n',
          '1 \n',
          'EOF',
          sep='',
          file=bash_script)

    return bash_script_filename


def run_bash_script(filename):
    """
    Run a bash script
    :param filename: name of the .sh file
    """
    print('Running bash script.......')
    os.system(bash + ' ' + filename)


def extract_resp_charges(filename='multiwfn_out.txt'):
    """
    From a Multiwfn output file extract the RESP charges and append them to a list (charges)
    :param filename: name of the multiwfn output file, default is set
    :return: list of charges
    """

    wfn_file = open(filename, 'r')
    charges = []
    read = False

    for line in wfn_file:

        if 'Sum' in line:
            read = False

        if read:
            try:
                # The partial charge is the last item in the block
                charges.append(float(line.split()[-1]))
            except TypeError:
                print('There is something wrong with the Multiwfn output file')
                exit()

        if line.split() == ['Center', 'Charge']:
            read = True

    if len(charges) == 0:
        print("Couldn't find any charges, will exit now")
        exit()

    print('Sum of charges is ', np.round(sum(charges), 6))

    return charges


def modify_top_with_resp_charges(filename, charges):
    """
    Modfy a GROMACS topology file (.top) to include different partial charges
    :param filename: name of .top file
    :param charges: list of partial charges, should be a list of floats
    """

    top_file = open(filename, 'r')
    top_file_lines = [line for line in top_file]            # not a memory efficient way to do it. may break

    modified_top_file = open(filename, 'w')
    atom_section = False
    charge_section = False

    for line in top_file_lines:

        if len(line.split()) == 0:
            charge_section = False

        if atom_section and charge_section:

            atom_number = int(line.split()[0])

            modified_line = (line.split()[:6] + [charges[atom_number - 1]] + line.split()[7:])
            line = modified_line

            print("{:>5s}{:>12s}{:>7s}{:>8s}{:>6s}{:>5s}{:>12.6f}{:>11.6f}".format(
                         modified_line[0],
                         modified_line[1],
                         modified_line[2],
                         modified_line[3],
                         modified_line[4],
                         modified_line[5],
                         float(modified_line[6]),
                         float(modified_line[7]),
                         ),
                  '\t', " ".join(modified_line[8:]),
                  file=modified_top_file)
        else:
            print(line, end='', file=modified_top_file)

        if '[ atoms ]' in line:
            atom_section = True
        if '; residue' in line:
            charge_section = True

    print('GROMACS topology modification was successful!')


def generate_topology(filename, charge, multiplicity):
    filename_no_extension = filename.replace('.xyz', '')
    residue_identifier = get_residue_label(filename)

    """
    Generate the .pdb file using OpenBabel and modify it with (1) the residue identifier and (2) labeled atoms e.g C1
    -----------------------------------------------------------------------------------------------------------------
    """
    pdb_filename = generate_pdb_file(filename)
    modify_pdb(pdb_filename, residue_label=residue_identifier)

    """
    Run Antechamber to generate a .mol2 file, then run paramcheck on that (both are AmberTools). Ensure params exist
    -----------------------------------------------------------------------------------------------------------------
    """
    mol2_filename = run_antechamber(pdb_filename, charge, multiplicity)
    frcmod_filename = run_paramcheck(mol2_filename)
    check_frcmod_file(base_filename=filename_no_extension)

    """
    Generate and run tleap to generate Amber topology files
    -----------------------------------------------------------------------------------------------------------------
    """
    tleap_filename = generate_tleap_in(base_filename=filename_no_extension, residue_label=residue_identifier)
    run_tleap(tleap_filename)

    """
    Convert the Amber topology files into Gromacs compatible files using Parmed
    -----------------------------------------------------------------------------------------------------------------
    """
    convert_amber2gromacs(base_filename=filename_no_extension)

    """
    Generate an ORCA input file at HF/6-31G* for the RESP calculation, then run it
    -----------------------------------------------------------------------------------------------------------------
    """
    inp_filename = generate_orca_input(filename, charge, multiplicity)
    run_orca(inp_filename)

    """
    Convert the ORCA output files into .molden, so Multiwfn can read it and compute RESP charges
    -----------------------------------------------------------------------------------------------------------------
    """
    molden_filename = generate_molden_file(base_filename=filename_no_extension)
    sh_filename = generate_multiwfn_script(base_filename=filename_no_extension)
    run_bash_script(sh_filename)

    """
    Extract the RESP charges from the Multiwfn output file and insert them into the GROMACS topology
    -----------------------------------------------------------------------------------------------------------------
    """
    resp_charges = extract_resp_charges()
    top_filename = filename_no_extension + '.top'
    modify_top_with_resp_charges(top_filename, charges=resp_charges)


def trash_files(filename):

    files_in_cwd = os.listdir(os.getcwd())
    basename = filename.replace('.xyz', '')

    for file in files_in_cwd:

        if basename in file and '.gro' not in file and '.top' not in file and '.xyz' not in file:
            os.remove(file)
        if 'ANTECHAMBER' in file or 'leap' in file:
            os.remove(file)
        if 'ATOMTYPE' in file:
            os.remove(file)
        if 'sqm' in file:
            os.remove(file)
        if 'multiwfn_out' in file:
            os.remove(file)


if __name__ == '__main__':

    # TODO fix call with multiple files

    args = get_args()
    [generate_topology(xyz_filename, charge=args.charge, multiplicity=args.mult) for xyz_filename in args.filename]
    if args.notrash is False:
        [trash_files(xyz_filename) for xyz_filename in args.filename]
